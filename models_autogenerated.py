"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""
# pylint: disable=no-member,super-init-not-called,unused-argument

import typing

import sqlalchemy
from sqlalchemy import orm

from open_alchemy import models

Base = models.Base  # type: ignore


class _FactDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    text: str
    entity: "EntityDict"


class FactDict(_FactDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TFact(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Fact.
        text: The text of the Fact.
        entity: The entity of the Fact.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: "sqlalchemy.Column[int]"
    text: "sqlalchemy.Column[str]"
    entity: 'sqlalchemy.Column["TEntity"]'

    def __init__(
        self, text: str, entity: "TEntity", id: typing.Optional[int] = None
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the Fact.
            text: The text of the Fact.
            entity: The entity of the Fact.

        """
        ...

    @classmethod
    def from_dict(
        cls, text: str, entity: "EntityDict", id: typing.Optional[int] = None
    ) -> "TFact":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Fact.
            text: The text of the Fact.
            entity: The entity of the Fact.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TFact":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> FactDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Fact: typing.Type[TFact] = models.Fact  # type: ignore


class _UserDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    username: str
    password: str


class UserDict(_UserDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TUser(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the User.
        username: The username of the User.
        password: The password of the User.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: "sqlalchemy.Column[int]"
    username: "sqlalchemy.Column[str]"
    password: "sqlalchemy.Column[str]"

    def __init__(
        self, username: str, password: str, id: typing.Optional[int] = None
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the User.
            username: The username of the User.
            password: The password of the User.

        """
        ...

    @classmethod
    def from_dict(
        cls, username: str, password: str, id: typing.Optional[int] = None
    ) -> "TUser":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the User.
            username: The username of the User.
            password: The password of the User.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TUser":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> UserDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


User: typing.Type[TUser] = models.User  # type: ignore


class _TagDictBase(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    name: str


class TagDict(_TagDictBase, total=False):
    """TypedDict for properties that are not required."""

    id: int


class TTag(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Tag.
        name: The name of the Tag.
        tagged: The tagged of the Tag.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: "sqlalchemy.Column[int]"
    name: "sqlalchemy.Column[str]"
    tagged: 'sqlalchemy.Column[typing.Sequence["TEntity"]]'

    def __init__(
        self,
        name: str,
        id: typing.Optional[int] = None,
        tagged: typing.Optional[typing.Sequence["TEntity"]] = None,
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the Tag.
            name: The name of the Tag.
            tagged: The tagged of the Tag.

        """
        ...

    @classmethod
    def from_dict(cls, name: str, id: typing.Optional[int] = None) -> "TTag":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Tag.
            name: The name of the Tag.
            tagged: The tagged of the Tag.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TTag":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> TagDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Tag: typing.Type[TTag] = models.Tag  # type: ignore


class EntityDict(typing.TypedDict, total=False):
    """TypedDict for properties that are not required."""

    id: int
    wikidata_id: typing.Optional[str]
    given_name: typing.Optional[str]
    nickname: typing.Optional[str]
    surname: typing.Optional[str]
    alphabetized_as: typing.Optional[str]
    is_real: typing.Optional[bool]
    is_living: typing.Optional[bool]
    birth_year: typing.Optional[str]
    gender: typing.Optional[str]
    score: typing.Optional[int]
    description: typing.Optional[str]
    tags: typing.Sequence["TagDict"]


class TEntity(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Entity.
        wikidata_id: The wikidata_id of the Entity.
        given_name: The given_name of the Entity.
        nickname: The nickname of the Entity.
        surname: The surname of the Entity.
        alphabetized_as: The alphabetized_as of the Entity.
        is_real: The is_real of the Entity.
        is_living: The is_living of the Entity.
        birth_year: The birth_year of the Entity.
        gender: The gender of the Entity.
        score: The score of the Entity.
        description: The description of the Entity.
        tags: The tags of the Entity.
        facts: The facts of the Entity.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: "sqlalchemy.Column[int]"
    wikidata_id: "sqlalchemy.Column[typing.Optional[str]]"
    given_name: "sqlalchemy.Column[typing.Optional[str]]"
    nickname: "sqlalchemy.Column[typing.Optional[str]]"
    surname: "sqlalchemy.Column[typing.Optional[str]]"
    alphabetized_as: "sqlalchemy.Column[typing.Optional[str]]"
    is_real: "sqlalchemy.Column[typing.Optional[bool]]"
    is_living: "sqlalchemy.Column[typing.Optional[bool]]"
    birth_year: "sqlalchemy.Column[typing.Optional[str]]"
    gender: "sqlalchemy.Column[typing.Optional[str]]"
    score: "sqlalchemy.Column[typing.Optional[int]]"
    description: "sqlalchemy.Column[typing.Optional[str]]"
    tags: 'sqlalchemy.Column[typing.Sequence["TTag"]]'
    facts: 'sqlalchemy.Column[typing.Sequence["TFact"]]'

    def __init__(
        self,
        id: typing.Optional[int] = None,
        wikidata_id: typing.Optional[str] = None,
        given_name: typing.Optional[str] = None,
        nickname: typing.Optional[str] = None,
        surname: typing.Optional[str] = None,
        alphabetized_as: typing.Optional[str] = None,
        is_real: typing.Optional[bool] = None,
        is_living: typing.Optional[bool] = None,
        birth_year: typing.Optional[str] = None,
        gender: typing.Optional[str] = None,
        score: typing.Optional[int] = None,
        description: typing.Optional[str] = None,
        tags: typing.Optional[typing.Sequence["TTag"]] = None,
        facts: typing.Optional[typing.Sequence["TFact"]] = None,
    ) -> None:
        """
        Construct.

        Args:
            id: The id of the Entity.
            wikidata_id: The wikidata_id of the Entity
            given_name: The given_name of the Entity.
            nickname: The nickname of the Entity.
            surname: The surname of the Entity.
            alphabetized_as: The alphabetized_as of the Entity.
            is_real: The is_real of the Entity.
            is_living: The is_living of the Entity.
            birth_year: The birth_year of the Entity.
            gender: The gender of the Entity.
            score: The score of the Entity.
            description: The description of the Entity.
            tags: The tags of the Entity.
            facts: The facts of the Entity.

        """
        ...

    @classmethod
    def from_dict(
        cls,
        id: typing.Optional[int] = None,
        wikidata_id: typing.Optional[str] = None,
        given_name: typing.Optional[str] = None,
        nickname: typing.Optional[str] = None,
        surname: typing.Optional[str] = None,
        alphabetized_as: typing.Optional[str] = None,
        is_real: typing.Optional[bool] = None,
        is_living: typing.Optional[bool] = None,
        birth_year: typing.Optional[str] = None,
        gender: typing.Optional[str] = None,
        score: typing.Optional[int] = None,
        description: typing.Optional[str] = None,
        tags: typing.Optional[typing.Sequence["TagDict"]] = None,
    ) -> "TEntity":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Entity.
            wikidata_id: The wikidata_id of the Entity
            given_name: The given_name of the Entity.
            nickname: The nickname of the Entity.
            surname: The surname of the Entity.
            alphabetized_as: The alphabetized_as of the Entity.
            is_real: The is_real of the Entity.
            is_living: The is_living of the Entity.
            birth_year: The birth_year of the Entity.
            gender: The gender of the Entity.
            score: The score of the Entity.
            description: The description of the Entity.
            tags: The tags of the Entity.
            facts: The facts of the Entity.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TEntity":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> EntityDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Entity: typing.Type[TEntity] = models.Entity  # type: ignore


class EntityTagsDict(typing.TypedDict, total=True):
    """TypedDict for properties that are required."""

    entities_id: int
    tags_id: int


class TEntityTags(typing.Protocol):
    """
    SQLAlchemy model protocol.

    Attrs:
        entities_id: The entities_id of the EntityTags.
        tags_id: The tags_id of the EntityTags.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    entities_id: "sqlalchemy.Column[int]"
    tags_id: "sqlalchemy.Column[int]"

    def __init__(self, entities_id: int, tags_id: int) -> None:
        """
        Construct.

        Args:
            entities_id: The entities_id of the EntityTags.
            tags_id: The tags_id of the EntityTags.

        """
        ...

    @classmethod
    def from_dict(cls, entities_id: int, tags_id: int) -> "TEntityTags":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            entities_id: The entities_id of the EntityTags.
            tags_id: The tags_id of the EntityTags.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TEntityTags":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> EntityTagsDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


EntityTags: typing.Type[TEntityTags] = models.EntityTags  # type: ignore
